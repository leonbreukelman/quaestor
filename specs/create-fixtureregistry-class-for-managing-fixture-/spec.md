# Feature Specification: FixtureRegistry Class for Managing Fixture Definitions

**Generated**: 2026-01-14T12:37:07.481909
**Status**: Draft
**Source**: Auto-generated by Smactorio workflow

---

## Overview

The FixtureRegistry class provides a centralized mechanism for managing fixture definitions in the testing framework. It allows developers to register, lookup, check existence, list, and clear fixture definitions while enforcing uniqueness constraints to prevent duplicate registrations.

## Problem Statement

Currently, there is no centralized way to manage fixture definitions in the testing framework. Developers need a registry pattern to organize, access, and manage fixture definitions without dealing with dependency resolution or scope management complexities. This registry will serve as the foundation for fixture management, building on the existing FixtureDefinition class.

---

## User Stories

### US1 - Register Fixture Definitions (Priority: P0)

As a **test framework developer**, I want to **register a FixtureDefinition with the registry**, so that **I can centrally manage all fixture definitions in one place**.

**Independent Test**: def test_register_fixture():
    registry = FixtureRegistry()
    definition = FixtureDefinition(name='test_fixture', factory=lambda: 'value')
    registry.register(definition)
    assert registry.has('test_fixture') is True

**Acceptance Criteria**:

1. register(definition: FixtureDefinition) method accepts a valid FixtureDefinition
2. After registration, the fixture is retrievable by its name
3. Method returns successfully when registration completes
4. The registry stores the complete FixtureDefinition object

### US2 - Retrieve Fixture by Name (Priority: P0)

As a **test framework developer**, I want to **look up a fixture definition by its name**, so that **I can access the fixture definition when I need to instantiate or inspect it**.

**Independent Test**: def test_get_fixture():
    registry = FixtureRegistry()
    definition = FixtureDefinition(name='my_fixture', factory=lambda: 42)
    registry.register(definition)
    retrieved = registry.get('my_fixture')
    assert retrieved.name == 'my_fixture'

**Acceptance Criteria**:

1. get(name: str) method returns the FixtureDefinition for a registered name
2. Return type is FixtureDefinition
3. Raises KeyError or appropriate exception when fixture name is not found
4. Lookup is case-sensitive

### US3 - Check Fixture Existence (Priority: P1)

As a **test framework developer**, I want to **check if a fixture is already registered**, so that **I can avoid duplicate registration errors and conditionally register fixtures**.

**Independent Test**: def test_has_fixture():
    registry = FixtureRegistry()
    assert registry.has('nonexistent') is False
    definition = FixtureDefinition(name='exists', factory=lambda: None)
    registry.register(definition)
    assert registry.has('exists') is True

**Acceptance Criteria**:

1. has(name: str) method returns True if fixture is registered
2. has(name: str) method returns False if fixture is not registered
3. Method does not raise exceptions for non-existent names
4. Return type is bool

### US4 - List All Registered Fixtures (Priority: P1)

As a **test framework developer**, I want to **retrieve a list of all registered fixture definitions**, so that **I can inspect and iterate over all available fixtures for debugging or documentation**.

**Independent Test**: def test_list_all_fixtures():
    registry = FixtureRegistry()
    assert registry.list_all() == []
    def1 = FixtureDefinition(name='fixture1', factory=lambda: 1)
    def2 = FixtureDefinition(name='fixture2', factory=lambda: 2)
    registry.register(def1)
    registry.register(def2)
    all_fixtures = registry.list_all()
    assert len(all_fixtures) == 2

**Acceptance Criteria**:

1. list_all() method returns list[FixtureDefinition]
2. Returns empty list when no fixtures are registered
3. Returns all registered fixtures in the list
4. Modifications to returned list do not affect registry state

### US5 - Clear Registry (Priority: P1)

As a **test framework developer**, I want to **clear all registered fixtures from the registry**, so that **I can reset the registry state between test runs or for isolation purposes**.

**Independent Test**: def test_clear_registry():
    registry = FixtureRegistry()
    definition = FixtureDefinition(name='to_clear', factory=lambda: 'data')
    registry.register(definition)
    assert registry.has('to_clear') is True
    registry.clear()
    assert registry.has('to_clear') is False
    assert registry.list_all() == []

**Acceptance Criteria**:

1. clear() method removes all registered fixtures
2. After clear(), has() returns False for previously registered fixtures
3. After clear(), list_all() returns empty list
4. Method completes without raising exceptions

### US6 - Detect Duplicate Registrations (Priority: P0)

As a **test framework developer**, I want to **receive an error when attempting to register a fixture with a name that already exists**, so that **I can identify configuration errors and prevent accidental fixture overwrites**.

**Independent Test**: def test_duplicate_registration_raises_error():
    registry = FixtureRegistry()
    def1 = FixtureDefinition(name='duplicate', factory=lambda: 1)
    def2 = FixtureDefinition(name='duplicate', factory=lambda: 2)
    registry.register(def1)
    with pytest.raises((ValueError, KeyError)) as exc_info:
        registry.register(def2)
    assert 'duplicate' in str(exc_info.value)

**Acceptance Criteria**:

1. Registering a fixture with an existing name raises an appropriate error
2. Error message includes the duplicate fixture name
3. Original fixture remains unchanged after failed duplicate registration
4. Error type is specific (e.g., DuplicateFixtureError or ValueError)

---

## Entities

### FixtureRegistry
**Type**: entity
**Description**: Central registry for managing FixtureDefinition instances
**Attributes**:
  - {'name': '_fixtures', 'type': 'dict[str, FixtureDefinition]', 'description': 'Internal storage mapping fixture names to definitions'}

### FixtureDefinition
**Type**: entity
**Description**: Existing class from quaestor/testing/fixtures.py representing a fixture definition

## Functional Requirements

FR-001: FR-001: The registry MUST provide a register() method that accepts a FixtureDefinition and stores it
FR-002: FR-002: The registry MUST provide a get() method that returns the FixtureDefinition for a given name
FR-003: FR-003: The registry MUST provide a has() method that returns boolean indicating if a fixture exists
FR-004: FR-004: The registry MUST provide a list_all() method that returns all registered FixtureDefinitions
FR-005: FR-005: The registry MUST provide a clear() method that removes all registered fixtures
FR-006: FR-006: The registry MUST raise an error when attempting to register a duplicate fixture name
FR-007: FR-007: The registry MUST NOT implement dependency resolution
FR-008: FR-008: The registry MUST NOT implement scope management

## Non-Functional Requirements

NFR-001: NFR-001: Lookup operations (get, has) should be O(1) time complexity
NFR-002: NFR-002: The registry should be thread-safe for read operations
NFR-003: NFR-003: Error messages should be descriptive and include relevant context

## Business Rules

- BR-001: Fixture names must be unique within a single registry instance
- BR-002: The clear() operation is destructive and requires explicit invocation (SAFETY-BY-DEFAULT principle)
- BR-003: The registry builds upon existing FixtureDefinition without modifying it

## Assumptions

- The existing FixtureDefinition class has a 'name' attribute that uniquely identifies it
- FixtureDefinition is imported from quaestor/testing/fixtures.py
- The registry is intended for single-process use cases initially
- Fixture names are strings and are case-sensitive

## Success Criteria

- All six user stories pass their acceptance criteria
- Unit tests achieve 100% code coverage for FixtureRegistry class
- Duplicate registration detection works correctly with descriptive error messages
- Integration with existing FixtureDefinition class is seamless
- All tests follow TDD approach (tests written before implementation)
- Documentation includes usage examples for each public method
