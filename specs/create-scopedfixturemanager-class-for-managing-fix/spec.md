# Feature Specification: ScopedFixtureManager for Scope-Based Fixture Lifecycle Management

**Generated**: 2026-01-14T12:52:21.327575
**Status**: Draft
**Source**: Auto-generated by Smactorio workflow

---

## Overview

The ScopedFixtureManager class provides scope-based caching and lifecycle management for test fixtures. It enables efficient fixture reuse within scope boundaries, automatic cleanup at scope transitions, and includes built-in fixtures for common testing needs like unique test identifiers and temporary directories.

## Problem Statement

Test fixtures often need to be shared within a scope (e.g., module, class, session) but cleaned up at scope boundaries. Without proper scope-based caching, fixtures are recreated unnecessarily, leading to slower tests and resource waste. Additionally, common fixtures like temporary directories and test identifiers need consistent implementation across test suites.

---

## User Stories

### US1 - Get or Create Cached Fixture (Priority: P0)

As a **test developer**, I want to **retrieve a cached fixture value or create a new one if not cached for the current scope**, so that **I can efficiently reuse expensive fixtures within a scope without manual caching logic**.

**Independent Test**: def test_get_or_create_caches_fixture():
    manager = ScopedFixtureManager()
    registry = FixtureRegistry()
    call_count = 0
    def factory():
        nonlocal call_count
        call_count += 1
        return f"value_{call_count}"
    
    result1 = manager.get_or_create("test_fixture", registry, factory)
    result2 = manager.get_or_create("test_fixture", registry, factory)
    
    assert result1 == result2 == "value_1"
    assert call_count == 1

**Acceptance Criteria**:

1. get_or_create returns cached value when fixture exists for current scope
2. get_or_create invokes factory and caches result when fixture not in cache
3. get_or_create accepts name, registry, and factory parameters
4. Cached values are isolated by scope level (function, class, module, session)
5. Same fixture name in different scopes maintains separate cached values

### US2 - Teardown Scope Fixtures (Priority: P0)

As a **test framework integrator**, I want to **destroy all fixtures at a scope boundary**, so that **resources are properly cleaned up when a test scope ends, preventing resource leaks**.

**Independent Test**: def test_teardown_scope_cleans_up_fixtures():
    manager = ScopedFixtureManager()
    registry = FixtureRegistry()
    cleanup_called = False
    
    def factory():
        return "test_value"
    
    manager.get_or_create("fixture", registry, factory, scope=FixtureScope.FUNCTION)
    manager.teardown_scope(FixtureScope.FUNCTION)
    
    # Fixture should be recreated after teardown
    call_count = 0
    def counting_factory():
        nonlocal call_count
        call_count += 1
        return call_count
    
    manager.get_or_create("fixture", registry, counting_factory, scope=FixtureScope.FUNCTION)
    assert call_count == 1

**Acceptance Criteria**:

1. teardown_scope accepts a FixtureScope parameter
2. All fixtures registered at the specified scope are destroyed
3. Fixtures at other scopes remain intact
4. Teardown invokes any registered cleanup handlers for fixtures
5. Cache is cleared for the torn-down scope

### US3 - Built-in Test ID Fixture (Priority: P1)

As a **test developer**, I want to **access a unique test identifier fixture**, so that **I can uniquely identify each test execution for logging, debugging, and resource naming**.

**Independent Test**: def test_builtin_test_id_is_unique():
    manager = ScopedFixtureManager()
    registry = FixtureRegistry()
    
    test_id_1 = manager.get_or_create("test_id", registry, None)
    
    manager.teardown_scope(FixtureScope.FUNCTION)
    
    test_id_2 = manager.get_or_create("test_id", registry, None)
    
    assert isinstance(test_id_1, str)
    assert isinstance(test_id_2, str)
    assert test_id_1 != test_id_2

**Acceptance Criteria**:

1. Built-in 'test_id' fixture is available without explicit registration
2. test_id returns a unique string identifier for each test
3. test_id format is human-readable and includes relevant context
4. test_id is consistent within a single test execution
5. test_id differs between separate test executions

### US4 - Built-in Temp Directory Fixture (Priority: P1)

As a **test developer**, I want to **access a temporary directory that is automatically cleaned up after the test**, so that **I can safely create temporary files without manual cleanup code or leftover artifacts**.

**Independent Test**: def test_builtin_temp_dir_is_cleaned_up():
    manager = ScopedFixtureManager()
    registry = FixtureRegistry()
    
    temp_dir = manager.get_or_create("temp_dir", registry, None)
    
    assert temp_dir.exists()
    assert temp_dir.is_dir()
    
    test_file = temp_dir / "test.txt"
    test_file.write_text("test content")
    
    manager.teardown_scope(FixtureScope.FUNCTION)
    
    assert not temp_dir.exists()

**Acceptance Criteria**:

1. Built-in 'temp_dir' fixture is available without explicit registration
2. temp_dir returns a Path object pointing to an existing directory
3. temp_dir directory is unique per test
4. temp_dir and all contents are deleted on scope teardown
5. temp_dir is writable and accessible during test execution

### US5 - Async Factory Support (Priority: P1)

As a **test developer**, I want to **use async factory functions to create fixtures**, so that **I can create fixtures that require async initialization like database connections or API clients**.

**Independent Test**: async def test_async_factory_support():
    manager = ScopedFixtureManager()
    registry = FixtureRegistry()
    
    async def async_factory():
        await asyncio.sleep(0.01)
        return "async_value"
    
    result = await manager.get_or_create("async_fixture", registry, async_factory, is_async=True)
    
    assert result == "async_value"

**Acceptance Criteria**:

1. get_or_create accepts is_async flag to indicate async factory
2. Async factories are awaited when is_async=True
3. Sync factories work normally when is_async=False (default)
4. Cached async fixture values are returned synchronously on subsequent calls
5. Async teardown handlers are properly awaited during scope cleanup

### US6 - Integration with Existing Fixture Infrastructure (Priority: P0)

As a **test framework integrator**, I want to **use ScopedFixtureManager with existing FixtureRegistry, FixtureResolver, and FixtureScope**, so that **I can leverage existing fixture infrastructure without rewriting existing code**.

**Independent Test**: def test_integration_with_fixture_registry():
    registry = FixtureRegistry()
    registry.register("existing_fixture", lambda: "existing_value", scope=FixtureScope.MODULE)
    
    manager = ScopedFixtureManager()
    
    result = manager.get_or_create("existing_fixture", registry, registry.get_factory("existing_fixture"))
    
    assert result == "existing_value"

**Acceptance Criteria**:

1. ScopedFixtureManager accepts FixtureRegistry instances
2. ScopedFixtureManager uses FixtureScope enum for scope management
3. ScopedFixtureManager is compatible with FixtureResolver for dependency resolution
4. Existing fixtures registered in FixtureRegistry are accessible via ScopedFixtureManager
5. No breaking changes to existing fixture APIs

---

## Entities

### ScopedFixtureManager
**Type**: entity
**Description**: Main class for managing fixture lifecycle with scope-based caching
**Attributes**:
  - {'name': '_cache', 'type': 'Dict[FixtureScope, Dict[str, Any]]', 'description': 'Scope-partitioned fixture cache'}
  - {'name': '_cleanup_handlers', 'type': 'Dict[FixtureScope, List[Callable]]', 'description': 'Registered cleanup handlers per scope'}

## Functional Requirements

FR-001: FR-001: ScopedFixtureManager.get_or_create SHALL return cached fixture value when fixture exists in cache for the specified scope
FR-002: FR-002: ScopedFixtureManager.get_or_create SHALL invoke factory function and cache result when fixture not in cache
FR-003: FR-003: ScopedFixtureManager.teardown_scope SHALL destroy all fixtures registered at the specified scope
FR-004: FR-004: ScopedFixtureManager.teardown_scope SHALL invoke cleanup handlers for destroyed fixtures
FR-005: FR-005: Built-in 'test_id' fixture SHALL return a unique string identifier per test execution
FR-006: FR-006: Built-in 'temp_dir' fixture SHALL return a Path to a temporary directory
FR-007: FR-007: Built-in 'temp_dir' fixture SHALL be deleted on scope teardown
FR-008: FR-008: ScopedFixtureManager SHALL support async factory functions via is_async parameter
FR-009: FR-009: ScopedFixtureManager SHALL integrate with existing FixtureRegistry for fixture storage

## Non-Functional Requirements

NFR-001: NFR-001: Fixture cache lookup SHALL complete in O(1) time complexity
NFR-002: NFR-002: ScopedFixtureManager SHALL be thread-safe for concurrent test execution
NFR-003: NFR-003: Memory usage SHALL scale linearly with number of cached fixtures
NFR-004: NFR-004: Teardown operations SHALL complete cleanup even if individual handlers raise exceptions

## Business Rules

- BR-001: Destructive operations (teardown_scope) MUST be explicit and intentional per SAFETY-BY-DEFAULT principle
- BR-002: Built-in fixtures SHALL NOT override user-registered fixtures with the same name
- BR-003: Scope hierarchy SHALL be respected: session > module > class > function
- BR-004: Async fixtures MUST be explicitly marked with is_async=True

## Assumptions

- FixtureRegistry, FixtureResolver, and FixtureScope exist in quaestor/testing/fixtures.py
- FixtureScope enum includes at minimum: FUNCTION, CLASS, MODULE, SESSION
- Existing fixture infrastructure follows established patterns from pytest
- Async support requires Python 3.8+ with asyncio

## Open Questions

- [ ] Should teardown_scope cascade to child scopes (e.g., tearing down MODULE also tears down CLASS and FUNCTION)?
- [ ] How should fixture dependency resolution interact with scope boundaries?
- [ ] Should built-in fixtures be overridable by user-defined fixtures?
- [ ] What happens if an async factory is called without is_async=True?

## Success Criteria

- All user stories have passing acceptance tests per TEST-FIRST principle
- ScopedFixtureManager integrates seamlessly with existing FixtureRegistry
- Built-in fixtures (test_id, temp_dir) work without additional configuration
- Both sync and async factories are fully supported
- Scope-based caching eliminates redundant fixture creation
- Teardown properly cleans up all resources without leaks
- Documentation includes usage examples for all public APIs
