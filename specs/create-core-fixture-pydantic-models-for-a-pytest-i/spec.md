# Feature Specification: Core Fixture Pydantic Models

**Generated**: 2026-01-14T12:29:59.855149
**Status**: Draft
**Source**: Auto-generated by Smactorio workflow

---

## Overview

This feature provides foundational Pydantic data models for a pytest-inspired fixture system. It includes a FixtureScope enum defining fixture lifetimes (TEST, SUITE, SESSION), a FixtureDefinition model capturing fixture metadata and configuration, and a FixtureValue model representing resolved fixture values with associated metadata. These models serve as the data layer foundation for fixture management without implementing registry or resolution logic.

## Problem Statement

The testing framework requires strongly-typed, validated data structures to represent fixtures throughout their lifecycle. Without well-defined models, fixture definitions would lack consistency, validation, and clear contracts between components. These models provide the foundation for future fixture registry and resolution systems while maintaining separation of concerns.

---

## User Stories

### US1 - Define Fixture Scope Levels (Priority: P0)

As a **test framework developer**, I want to **use a FixtureScope enum to specify fixture lifetime granularity**, so that **I can clearly communicate and enforce when fixtures should be created and destroyed (per-test, per-suite, or per-session)**.

**Independent Test**: test_fixture_scope_enum_has_three_values:
  - Assert FixtureScope.TEST exists and equals 'test'
  - Assert FixtureScope.SUITE exists and equals 'suite'
  - Assert FixtureScope.SESSION exists and equals 'session'
  - Assert len(FixtureScope) == 3

**Acceptance Criteria**:

1. FixtureScope enum exists with exactly three values: TEST, SUITE, SESSION
2. Each scope value is a string-backed enum for serialization compatibility
3. Enum values can be compared for equality
4. Invalid scope values raise validation errors when used with Pydantic models

### US2 - Create Fixture Definition Model (Priority: P0)

As a **test framework developer**, I want to **define fixtures using a FixtureDefinition model with name, scope, description, dependencies, and async flag**, so that **I can declaratively specify fixture configurations with full validation and type safety**.

**Independent Test**: test_fixture_definition_creation_and_validation:
  - Create FixtureDefinition with name='db_session', scope=FixtureScope.SUITE
  - Assert all fields are accessible and correctly typed
  - Attempt to create FixtureDefinition with empty name, expect ValidationError
  - Verify default values for scope, dependencies, and is_async

**Acceptance Criteria**:

1. FixtureDefinition model has required 'name' field of type str
2. FixtureDefinition model has 'scope' field defaulting to FixtureScope.TEST
3. FixtureDefinition model has optional 'description' field of type str
4. FixtureDefinition model has 'dependencies' field as list of strings, defaulting to empty list
5. FixtureDefinition model has 'is_async' boolean field defaulting to False
6. Model validates that 'name' is non-empty
7. Model is immutable (frozen) after creation

### US3 - Create Fixture Value Model (Priority: P0)

As a **test framework developer**, I want to **wrap resolved fixture values in a FixtureValue model with metadata**, so that **I can track fixture state, creation time, and associated definition alongside the actual value**.

**Independent Test**: test_fixture_value_wraps_resolved_value:
  - Create FixtureDefinition for 'test_client'
  - Create FixtureValue with value={'client': 'mock'}, definition=fixture_def
  - Assert created_at is populated with current time
  - Assert value and definition are accessible
  - Create FixtureValue with value=None, verify it's valid

**Acceptance Criteria**:

1. FixtureValue model has 'value' field accepting Any type
2. FixtureValue model has 'definition' field referencing the FixtureDefinition
3. FixtureValue model has 'created_at' datetime field auto-populated on creation
4. FixtureValue model has optional 'error' field for capturing setup failures
5. Model supports None as a valid fixture value
6. Model is immutable (frozen) after creation

### US4 - Follow Existing Model Patterns (Priority: P1)

As a **test framework developer**, I want to **use models that follow the established patterns in quaestor/testing/models.py**, so that **the codebase remains consistent and maintainable with predictable model behaviors**.

**Independent Test**: test_models_follow_existing_patterns:
  - Import existing models from quaestor/testing/models.py
  - Verify FixtureDefinition and FixtureValue use similar configuration
  - Check that frozen=True is set on model_config
  - Verify Field descriptions are present for documentation

**Acceptance Criteria**:

1. Models inherit from appropriate Pydantic BaseModel or use consistent configuration
2. Models use Field() for default values and descriptions
3. Models are placed in the appropriate module location
4. Models follow existing naming conventions
5. Models include proper __repr__ or model_config for debugging

### US5 - Serialize and Deserialize Fixture Models (Priority: P1)

As a **test framework developer**, I want to **serialize fixture definitions and values to JSON and deserialize them back**, so that **I can persist fixture configurations and share them across processes or store them for debugging**.

**Independent Test**: test_fixture_model_serialization_roundtrip:
  - Create FixtureDefinition with all fields populated
  - Serialize to JSON string
  - Deserialize back to FixtureDefinition
  - Assert all fields match original values
  - Verify scope enum is correctly serialized/deserialized

**Acceptance Criteria**:

1. FixtureDefinition can be serialized to JSON via model_dump_json()
2. FixtureDefinition can be deserialized from JSON via model_validate_json()
3. FixtureScope enum serializes as its string value
4. FixtureValue serialization handles datetime fields correctly
5. Round-trip serialization preserves all field values

---

## Entities

### FixtureScope
**Type**: enum
**Description**: Enumeration defining fixture lifetime scopes

### FixtureDefinition
**Type**: model
**Description**: Pydantic model representing a fixture's configuration and metadata

### FixtureValue
**Type**: model
**Description**: Pydantic model representing a resolved fixture value with metadata

## Functional Requirements

FR-001: FR-001: System SHALL provide FixtureScope enum with TEST, SUITE, and SESSION values
FR-002: FR-002: System SHALL provide FixtureDefinition model with name, scope, description, dependencies, and is_async fields
FR-003: FR-003: System SHALL provide FixtureValue model with value, definition, created_at, and error fields
FR-004: FR-004: FixtureDefinition.name SHALL be required and non-empty
FR-005: FR-005: FixtureDefinition.scope SHALL default to FixtureScope.TEST
FR-006: FR-006: FixtureDefinition.dependencies SHALL default to empty list
FR-007: FR-007: FixtureDefinition.is_async SHALL default to False
FR-008: FR-008: FixtureValue.created_at SHALL be auto-populated with current UTC datetime
FR-009: FR-009: All models SHALL be immutable (frozen) after creation
FR-010: FR-010: All models SHALL support JSON serialization and deserialization

## Non-Functional Requirements

NFR-001: NFR-001: Models SHALL follow existing patterns in quaestor/testing/models.py
NFR-002: NFR-002: Models SHALL use Pydantic v2 syntax and features
NFR-003: NFR-003: Models SHALL include Field descriptions for documentation generation
NFR-004: NFR-004: Model validation errors SHALL provide clear error messages

## Business Rules

- BR-001: Fixture names must be valid Python identifiers (enforced by convention, not validation)
- BR-002: Dependencies list contains fixture names that must exist (validation deferred to registry)
- BR-003: Session-scoped fixtures should be used sparingly as they persist across all tests
- BR-004: Async fixtures (is_async=True) require async test runners

## Assumptions

- Pydantic v2 is available in the project dependencies
- The existing quaestor/testing/models.py provides patterns to follow
- Fixture registry and resolution will be implemented in separate features
- UTC timezone is used for all datetime fields

## Open Questions

- [ ] Should FixtureDefinition include a 'factory' or 'callable' field for the fixture function reference, or is that handled by the registry?
- [ ] Should there be validation that dependency names are valid Python identifiers?
- [ ] Should FixtureValue include a 'teardown_called' flag to track cleanup state?

## Success Criteria

- All three models (FixtureScope, FixtureDefinition, FixtureValue) are implemented and pass validation
- 100% test coverage for all model fields and validation logic
- Models follow TDD approach with tests written before implementation
- Models are consistent with existing patterns in quaestor/testing/models.py
- JSON serialization round-trip works correctly for all models
- Documentation strings are present on all models and fields
